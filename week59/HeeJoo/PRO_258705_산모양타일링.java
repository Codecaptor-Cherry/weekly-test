/*
 * n = 1) [0] 2 + 1 = 3
 * n = 1) [1] 3 + 1 = 4
 * n = 2) [0, 0] 8 ~ (2 * 2 + 1 * 1) + (2 * 1 + 1 * 1)
 * n = 2) [0, 1] 11 ~ (2 * 3 + 1 * 2) + (2 * 1 + 1 * 1)
 * n = 2) [1, 0] 11 ~ (3 * 2 + 1 * 1) + (3 * 1 + 1 * 1)
 * n = 2) [1, 1] 15 ~ (3 * 3 + 1 * 2) + (3 * 1 + 1 * 1)

 * 1. 이전 모양이 /\ 로 끝나는지 \_\ 로 끝나는지
 * 2. 다음 연장 모양이 사다리꼴인지 정삼각형인지
 * 위 두 기준에 따라 경우의 수가 달라짐
 
 * 1. /\로 끝나고, 사다리꼴 연장인 경우) 3가지 경우 가능 /\/\ | /_/\ | /\_\ -> /\로 끝나는 경우 2 + \_\로 끝나는 경우 1
 * △는 위에 얹어진 삼각형, ◆는 세로 마름모
 * 2. \_\로 끝나고, 사다리꼴 연장인 경우) 2가지 경우 가능 \_\/\ | \_\_\ -> /\로 끝나는 경우 1 + \_\로 끝나는 경우 1
 * 3. /\로 끝나고, 정삼각형 연장인 경우) 4가지 경우 가능 /\/△/\ | /_/△/\ | /\◆/\ | /\△\_\ -> /\로 끝나는 경우 3 + \_\로 끝나는 경우 1
 * 4. \_\로 끝나고, 정삼각형 연장인 경우) 3가지 경우 가능 \_\/△/\ | \_\◆/\ | \_\△\_\ -> /\로 끝나는 경우 2 + \_\로 끝나는 경우 1
 */

class Solution {
    static final int MOD = 10007;
    public int solution(int n, int[] tops) {
        int answer = 0;

        // 끝나는 모양에 따라 경우의 수 따로 저장
        // dp[n][0] : /\
        // dp[n][1] : \_\
        int[][] dp = new int[n + 1][2];

        if(tops[0] == 0) { // 첫 모양이 사다리꼴인 경우
            dp[1][0] = 2;
        } else {
            dp[1][0] = 3; // 첫 모양이 정삼각형인 경우
        }
        dp[1][1] = 1; // 상관없이 1개 나옴
        
        for(int i = 2; i <= n; i++) {
            if(tops[i - 1] == 0) { // 다음 모양이 사다리꼴인 경우 // dp는 0인덱스 사용 x, tops는 0인덱스 사용 o
                dp[i][0] = dp[i - 1][0] * 2 + dp[i - 1][1]; // /\로 끝나는 경우 = 1번 * 2 + 2번 * 1
                dp[i][1] = dp[i - 1][0] + dp[i - 1][1]; // \_\로 끝나는 경우 = 1번 * 1 + 2번 * 1
            } else { // 다음 모양이 정삼각형인 경우
                dp[i][0] = dp[i - 1][0] * 3 + dp[i - 1][1] * 2; // /\로 끝나는 경우 = 3번 * 3 + 4번 * 2
                dp[i][1] = dp[i - 1][0] + dp[i - 1][1]; // \_\로 끝나는 경우 = 3번 * 1 + 4번 + 1
            }
            
            dp[i][0] %= MOD;
            dp[i][1] %= MOD;
        }
        
        answer = dp[n][0] + dp[n][1];
        return answer % MOD;
    }
}
